{"componentChunkName":"component---src-pages-restrict-complete-status-mdx","path":"/restrict-complete-status/","result":{"pageContext":{"frontmatter":{"title":"Restrict COMPLETE Status from options"},"relativePagePath":"/restrict-complete-status.mdx","titleType":"append","MdxNode":{"id":"b4bfff45-3b0c-52c7-af67-6e8d9eefc315","children":[],"parent":"92bbfbf4-715d-5fb4-b9d6-1101e0428b91","internal":{"content":"---\ntitle: Restrict COMPLETE Status from options\n---\n\n## About this task\n\nThis guide instructs you to disable the COMPLETE option until the following conditions are met:\n1. The work order must contain at least one work log entry;\n2. Must contain an actual labor entry (for current labor);\n3. If work type is different from PM, check for presence of asset and the existence of complete PCR (Problem, Cause,\nRemedy) entry;\n4. If work type is PM, no need to have an asset or PCR entry.\nIn this customization, the COMPLETE option is removed from the status change lookups. The Work Order completion must be\ncompleted through the report page, if the conditions are met.\n\n## Procedure\n\n### Step 1: Add a boolean page state to the report_work page\n\n```xml\n<states id=\"jy5r4\">\n[...]\n<state name=\"disableCompleted\" value=\"false\" type=\"boolean\" id=\"trg_g8n3b\"/>\n</states>\n```\n\n### Step 2: In the app.xml file, include the hidecompleted state to the disable condition on the button (p6aav)\n\n```xml\n<button slot=\"buttons\" label=\"Complete work\" kind=\"primary\" id=\"p6aav\" […]\ndisabled=\"{page.state.disableCompleted || woDetailsReportWork.item.flowcontrolled || !app.checkSigOption(`$\n{app.state.woOSName}.COMPWOBUTTON`)}\"/>\n```\n\n### Step 3: In the AppCustomization.js file, declare the dialogOpened method to handle the window opening event. The code inside\nthe method should contain the verification of the name of the dialog that was opened, the existence of the datasource and the\nconfirmation of the current page before executing the filter, “item.maxvalue !== 'COMP'”, insert the following logic in the method:\n\n```js\n  /**\n   * dialogOpened handler filter out complete status when opened\n   * @param {Object} obj\n   * @param {Dialog} obj.dialog\n   */\n  dialogOpened({dialog}) {\n\n    // page name when dialog is open\n    this.app.log.d(TAG,`dialog ${dialog?.name} opened at ${this.app.currentPage.name} page`);\n\n    if (dialog?.name === 'woStatusChangeDialog') {\n\n      // Check status domain datasource existence\n      const statusDS = this.app.findDatasource('dsstatusDomainList');\n      if (!statusDS) {\n        this.app.log.e(TAG,'statusDS unknown to perform filter');\n        return;\n      }\n\n      // check if dialog opened is one of the allowed pages and name matches status dialog\n      if (['workOrderDetails', 'schedule'].some(page => page === this.app.currentPage.name)) {\n        // Remove COMP status temporarily from status domain \n        statusDS.applyInMemoryFilter((item) => item.maxvalue !== 'COMP');\n        statusDS.load();\n      } else {\n        // Reset temporarily filter from status domain\n        statusDS.clearInMemoryFilter();\n      }\n    }\n  }\n```\n\n### Step 4: Create a method to check if a given list contains full failure report (Problem, Cause and Remedy)\n\n```js\n/**\n   * Validates Problem, Cause and Remedy inside failure report list\n   * @private\n   * @param {Array} failureReport - failure report list.\n   * @returns {boolean} Promise of an array of items.\n   */\n  hasPCR(failureReport = []) {\n    let hasProblem = false;\n    let hasCause = false;\n    let hasRemedy = false;\n    for (const failure of failureReport) {\n      if (!hasProblem && failure.type_maxvalue === 'PROBLEM'){\n        hasProblem = true;\n      }\n      if (!hasCause && failure.type_maxvalue === 'CAUSE'){\n        hasCause = true;\n      }\n      if (!hasRemedy && failure.type_maxvalue === 'REMEDY'){\n        hasRemedy = true;\n      }\n    }\n    return hasProblem && hasCause && hasRemedy;\n  }\n```\n\n### Step 5: Create the main method responsible to output if the a work order item can be completed based on the criteria discussed.\n\n```js\n /**\n   * Validation to allow completion. Validation is:\n   * a.\tshould have work Log comments\n   * b.\tshould have labor actuals\n   * c.\tshould have Problem Cause and Remedy codes IF Work Type is not in [PM] and there is an Asset on the record\n   * This should only be called from report_work page\n   * @param {Application} app \n   * @returns {boolean} \n   */\n  async isCompleteEnabled(app) {\n\n    // Check ds initialization\n    const currentWO = app.findDatasource(\"woDetailResource\");\n    if (!currentWO || !currentWO.initialized) {\n      this.app.log.e(TAG,'woDetailResource not initialized');\n      return;\n    }\n\n    // Check ds initialization\n    const wlogDS = app.findDatasource(\"woDetailsWorklogDs\");\n    if (!wlogDS || !wlogDS.initialized) {\n      this.app.log.e(TAG,'woDetailsWorklogDs not initialized');\n      return;\n    }\n\n    const workItem = currentWO?.item;\n    if (!workItem) {\n      this.app.log.e(TAG,'something is wrong. No work item defined');\n      return;\n    }\n    this.app.log.d(TAG,JSON.stringify({wonum: workItem?.wonum, assetnum: workItem?.assetnum, workType: workItem?.worktype, href: workItem?.href}));\n    \n    // Load parent of reportworkLabords\n    const woDetailsReportWorkDS = app.findDatasource(\"woDetailsReportWork\");\n    await woDetailsReportWorkDS.load({\n      noCache: true,\n      itemUrl: workItem?.href,\n    });\n    // Check ds initialization\n    const ltransDS = app.findDatasource(\"reportworkLaborDetailds\");\n    if (!ltransDS || !ltransDS.initialized) {\n      this.app.log.e(TAG,'reportworkLaborDetailds not initialized');\n      return;\n    }\n    // Force load of labor transaction DS\n    await ltransDS.forceReload();\n\n    if (!wlogDS?.items || !ltransDS?.items) {\n      this.app.log.d(TAG,'missing worklogs or labor transactions');\n    }\n\n    this.app.log.d(TAG,`has workLog:${!!wlogDS.items.length} / has labor:${!!ltransDS.items.length}`);\n    // Build part of validation considering work logs and labor actual\n    let enableComplete = !!wlogDS.items.length && !!ltransDS.items.length;\n\n    //shouldCheckPCR when there is asset and work type is not in [PM]\n    this.app.log.d(TAG,`wonum ${workItem?.wonum} / asset ${workItem?.assetnum} / worktype ${workItem?.worktype}`);\n\n    // shouldFullCheckPCR when there is asset and work type is not in [PM] \n    if (enableComplete && workItem.assetnum && !['PM'].includes(workItem.worktype)) {\n\n      const failureReport = woDetailsReportWorkDS.item?.failurereport || [];\n      this.app.log.d(TAG,JSON.stringify(failureReport));\n      enableComplete = this.hasPCR(failureReport);\n      \n    }\n    return enableComplete;\n  }\n```\n\n### Step 6: Apply validation using the previous method to update the state created.\n\n```js\n/**\n   * Enables/disables complete button from report work page based on complete validation\n   * @param {Page} page \n   * @param {App} app \n   */\n  async addCompleteButtonValidation(page, app) {\n    // Set disable before starting processing condition\n    page.state.disableCompleted=true;\n    // Get validation result\n    const enableComplete = await this.isCompleteEnabled(app);\n    this.app.log.d(TAG, `Setting complete button to ${enableComplete}`);\n    // Set complete button according to validation\n    page.state.disableCompleted=!enableComplete;\n  }\n```\n\n### Step 7: Bind buttonValidation method to pageResumed lifecycle hook when it is the correct page.\n\n```js\n  pageResumed(page, app) {\n    // Run validation for complete button \n    if (app.currentPage.name === 'report_work' && page.name==='report_work') {\n      this.app.log.d(TAG,'entering add completebuttonvalidation logic');\n      this.addCompleteButtonValidation(page, app);\n    }\n  }\n```\n","type":"Mdx","contentDigest":"03dce19ab6fdce6e5a54427423f69b54","owner":"gatsby-plugin-mdx","counter":77},"frontmatter":{"title":"Restrict COMPLETE Status from options"},"exports":{},"rawBody":"---\ntitle: Restrict COMPLETE Status from options\n---\n\n## About this task\n\nThis guide instructs you to disable the COMPLETE option until the following conditions are met:\n1. The work order must contain at least one work log entry;\n2. Must contain an actual labor entry (for current labor);\n3. If work type is different from PM, check for presence of asset and the existence of complete PCR (Problem, Cause,\nRemedy) entry;\n4. If work type is PM, no need to have an asset or PCR entry.\nIn this customization, the COMPLETE option is removed from the status change lookups. The Work Order completion must be\ncompleted through the report page, if the conditions are met.\n\n## Procedure\n\n### Step 1: Add a boolean page state to the report_work page\n\n```xml\n<states id=\"jy5r4\">\n[...]\n<state name=\"disableCompleted\" value=\"false\" type=\"boolean\" id=\"trg_g8n3b\"/>\n</states>\n```\n\n### Step 2: In the app.xml file, include the hidecompleted state to the disable condition on the button (p6aav)\n\n```xml\n<button slot=\"buttons\" label=\"Complete work\" kind=\"primary\" id=\"p6aav\" […]\ndisabled=\"{page.state.disableCompleted || woDetailsReportWork.item.flowcontrolled || !app.checkSigOption(`$\n{app.state.woOSName}.COMPWOBUTTON`)}\"/>\n```\n\n### Step 3: In the AppCustomization.js file, declare the dialogOpened method to handle the window opening event. The code inside\nthe method should contain the verification of the name of the dialog that was opened, the existence of the datasource and the\nconfirmation of the current page before executing the filter, “item.maxvalue !== 'COMP'”, insert the following logic in the method:\n\n```js\n  /**\n   * dialogOpened handler filter out complete status when opened\n   * @param {Object} obj\n   * @param {Dialog} obj.dialog\n   */\n  dialogOpened({dialog}) {\n\n    // page name when dialog is open\n    this.app.log.d(TAG,`dialog ${dialog?.name} opened at ${this.app.currentPage.name} page`);\n\n    if (dialog?.name === 'woStatusChangeDialog') {\n\n      // Check status domain datasource existence\n      const statusDS = this.app.findDatasource('dsstatusDomainList');\n      if (!statusDS) {\n        this.app.log.e(TAG,'statusDS unknown to perform filter');\n        return;\n      }\n\n      // check if dialog opened is one of the allowed pages and name matches status dialog\n      if (['workOrderDetails', 'schedule'].some(page => page === this.app.currentPage.name)) {\n        // Remove COMP status temporarily from status domain \n        statusDS.applyInMemoryFilter((item) => item.maxvalue !== 'COMP');\n        statusDS.load();\n      } else {\n        // Reset temporarily filter from status domain\n        statusDS.clearInMemoryFilter();\n      }\n    }\n  }\n```\n\n### Step 4: Create a method to check if a given list contains full failure report (Problem, Cause and Remedy)\n\n```js\n/**\n   * Validates Problem, Cause and Remedy inside failure report list\n   * @private\n   * @param {Array} failureReport - failure report list.\n   * @returns {boolean} Promise of an array of items.\n   */\n  hasPCR(failureReport = []) {\n    let hasProblem = false;\n    let hasCause = false;\n    let hasRemedy = false;\n    for (const failure of failureReport) {\n      if (!hasProblem && failure.type_maxvalue === 'PROBLEM'){\n        hasProblem = true;\n      }\n      if (!hasCause && failure.type_maxvalue === 'CAUSE'){\n        hasCause = true;\n      }\n      if (!hasRemedy && failure.type_maxvalue === 'REMEDY'){\n        hasRemedy = true;\n      }\n    }\n    return hasProblem && hasCause && hasRemedy;\n  }\n```\n\n### Step 5: Create the main method responsible to output if the a work order item can be completed based on the criteria discussed.\n\n```js\n /**\n   * Validation to allow completion. Validation is:\n   * a.\tshould have work Log comments\n   * b.\tshould have labor actuals\n   * c.\tshould have Problem Cause and Remedy codes IF Work Type is not in [PM] and there is an Asset on the record\n   * This should only be called from report_work page\n   * @param {Application} app \n   * @returns {boolean} \n   */\n  async isCompleteEnabled(app) {\n\n    // Check ds initialization\n    const currentWO = app.findDatasource(\"woDetailResource\");\n    if (!currentWO || !currentWO.initialized) {\n      this.app.log.e(TAG,'woDetailResource not initialized');\n      return;\n    }\n\n    // Check ds initialization\n    const wlogDS = app.findDatasource(\"woDetailsWorklogDs\");\n    if (!wlogDS || !wlogDS.initialized) {\n      this.app.log.e(TAG,'woDetailsWorklogDs not initialized');\n      return;\n    }\n\n    const workItem = currentWO?.item;\n    if (!workItem) {\n      this.app.log.e(TAG,'something is wrong. No work item defined');\n      return;\n    }\n    this.app.log.d(TAG,JSON.stringify({wonum: workItem?.wonum, assetnum: workItem?.assetnum, workType: workItem?.worktype, href: workItem?.href}));\n    \n    // Load parent of reportworkLabords\n    const woDetailsReportWorkDS = app.findDatasource(\"woDetailsReportWork\");\n    await woDetailsReportWorkDS.load({\n      noCache: true,\n      itemUrl: workItem?.href,\n    });\n    // Check ds initialization\n    const ltransDS = app.findDatasource(\"reportworkLaborDetailds\");\n    if (!ltransDS || !ltransDS.initialized) {\n      this.app.log.e(TAG,'reportworkLaborDetailds not initialized');\n      return;\n    }\n    // Force load of labor transaction DS\n    await ltransDS.forceReload();\n\n    if (!wlogDS?.items || !ltransDS?.items) {\n      this.app.log.d(TAG,'missing worklogs or labor transactions');\n    }\n\n    this.app.log.d(TAG,`has workLog:${!!wlogDS.items.length} / has labor:${!!ltransDS.items.length}`);\n    // Build part of validation considering work logs and labor actual\n    let enableComplete = !!wlogDS.items.length && !!ltransDS.items.length;\n\n    //shouldCheckPCR when there is asset and work type is not in [PM]\n    this.app.log.d(TAG,`wonum ${workItem?.wonum} / asset ${workItem?.assetnum} / worktype ${workItem?.worktype}`);\n\n    // shouldFullCheckPCR when there is asset and work type is not in [PM] \n    if (enableComplete && workItem.assetnum && !['PM'].includes(workItem.worktype)) {\n\n      const failureReport = woDetailsReportWorkDS.item?.failurereport || [];\n      this.app.log.d(TAG,JSON.stringify(failureReport));\n      enableComplete = this.hasPCR(failureReport);\n      \n    }\n    return enableComplete;\n  }\n```\n\n### Step 6: Apply validation using the previous method to update the state created.\n\n```js\n/**\n   * Enables/disables complete button from report work page based on complete validation\n   * @param {Page} page \n   * @param {App} app \n   */\n  async addCompleteButtonValidation(page, app) {\n    // Set disable before starting processing condition\n    page.state.disableCompleted=true;\n    // Get validation result\n    const enableComplete = await this.isCompleteEnabled(app);\n    this.app.log.d(TAG, `Setting complete button to ${enableComplete}`);\n    // Set complete button according to validation\n    page.state.disableCompleted=!enableComplete;\n  }\n```\n\n### Step 7: Bind buttonValidation method to pageResumed lifecycle hook when it is the correct page.\n\n```js\n  pageResumed(page, app) {\n    // Run validation for complete button \n    if (app.currentPage.name === 'report_work' && page.name==='report_work') {\n      this.app.log.d(TAG,'entering add completebuttonvalidation logic');\n      this.addCompleteButtonValidation(page, app);\n    }\n  }\n```\n","fileAbsolutePath":"/home/travis/build/maximo-app-framework/configuration-practices-documentation/src/pages/restrict-complete-status.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}